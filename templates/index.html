<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PiRate TV Remote</title>
    <style>
        body { font-family: sans-serif; background-color: #282c34; color: white; padding: 20px; }
        .container { max-width: 800px; margin: auto; }
        .controls, .upload, .status, .browser { background-color: #444; border-radius: 8px; padding: 20px; margin-bottom: 20px; }
        h1, h2 { color: #61dafb; }
        button { background-color: #61dafb; color: black; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; margin: 5px; }
        button:hover { background-color: #21a1f2; }
        input[type="file"] { margin-top: 10px; }
        #status-message { margin-top: 10px; color: #999; }
        .browser-list { list-style: none; padding: 0; }
        .browser-list li { padding: 8px; cursor: pointer; border-bottom: 1px solid #555; }
        .browser-list li:hover { background-color: #555; }
        .browser-list li.dir { color: #61dafb; font-weight: bold; }
        .browser-list li.file { color: #ccc; }
        .control-row { margin-bottom: 10px; text-align: center; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
</head>
<body>
    <div class="container">
        <h1>PITV Remote Control</h1>

        <div class="video-stream" style="margin-bottom: 20px;">
            <h2>Video Player</h2>
            <video id="video-player" width="100%" controls autoplay>
                Your browser does not support the video tag.
            </video>
        </div>

        <div class="controls">
            <h2>Device Remote</h2>
            
            <div class="control-row">
                <button onclick="sendCommand('/rewind')">Rewind</button>
                <button onclick="sendCommand('/play')">Play/Pause</button>
                <button onclick="sendCommand('/fast_forward')">Fast Forward</button>
            </div>

            <div class="control-row">
                <button onclick="sendCommand('/prev')">Prev Episode</button>
                <button onclick="sendCommand('/next')">Next Episode</button>
            </div>

            <div class="control-row">
                <button onclick="sendCommand('/next_show')">Next Show</button>
            </div>

            <div class="control-row">
                <button onclick="sendCommand('/toggle_shuffle')">Toggle Shuffle</button>
                <button onclick="sendCommand('/rotate_screen')">Rotate Screen</button>
            </div>
        </div>

        <div class="browser">
            <h2>File Browser</h2>
            <h3 id="current-path">/</h3>
            <ul id="file-browser-list" class="browser-list"></ul>
        </div>

        <div class="upload">
            <h2>Upload Media</h2>
            <form id="upload-form" enctype="multipart/form-data">
                <input type="file" name="files[]" id="file-input" multiple required webkitdirectory>
                <button type="submit">Upload</button>
            </form>
        </div>

        <div class="status">
            <h2>Status</h2>
            <div id="status-message">Ready</div>
        </div>
    </div>

    <script>
        let currentPath = '';

        async function sendCommand(endpoint, body = null) {
            const statusDiv = document.getElementById('status-message');
            statusDiv.textContent = `Sending command: ${endpoint}...`;
            try {
                const options = {
                    method: 'POST',
                    headers: body ? { 'Content-Type': 'application/json' } : {},
                    body: body ? JSON.stringify(body) : null
                };
                const response = await fetch(endpoint, options);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                statusDiv.textContent = `Command successful: ${JSON.stringify(result)}`;
                return result;
            } catch (error) {
                statusDiv.textContent = `Error: ${error.message}`;
                throw error;
            }
        }

        async function browse(path) {
            const statusDiv = document.getElementById('status-message');
            statusDiv.textContent = `Browsing: ${path}...`;
            try {
                const browsePath = path ? `/${path}` : '';
                const response = await fetch(`/browse${browsePath}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                updateBrowser(path, data);
            } catch (error) {
                statusDiv.textContent = `Error: ${error.message}`;
            }
        }

        function updateBrowser(path, data) {
            currentPath = path;
            document.getElementById('current-path').textContent = `/${path}`;
            const list = document.getElementById('file-browser-list');
            list.innerHTML = '';

            // Add '..' for parent directory
            if (path) {
                const parentPath = path.substring(0, path.lastIndexOf('/'));
                const parentLi = document.createElement('li');
                parentLi.textContent = '..';
                parentLi.className = 'dir';
                parentLi.onclick = () => browse(parentPath);
                list.appendChild(parentLi);
            }

            data.dirs.forEach(dir => {
                const li = document.createElement('li');
                li.textContent = dir;
                li.className = 'dir';
                const newPath = path ? `${path}/${dir}` : dir;
                li.onclick = () => browse(newPath);
                list.appendChild(li);
            });

            data.files.forEach(file => {
                const li = document.createElement('li');
                li.textContent = file;
                li.className = 'file';
                const filePath = path ? `${path}/${file}` : file;
                li.onclick = () => playMedia(filePath);
                list.appendChild(li);
            });
        }

        function playMedia(path) {
            const videoPlayer = document.getElementById('video-player');
            videoPlayer.src = `/media/${path}`;
            videoPlayer.play();
            sendCommand('/play_media', { path: path });
        }

        const uploadForm = document.getElementById('upload-form');
        uploadForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const statusDiv = document.getElementById('status-message');
            const fileInput = document.getElementById('file-input');
            const formData = new FormData();

            if (fileInput.files.length === 0) {
                statusDiv.textContent = 'Please select files to upload.';
                return;
            }

            for (const file of fileInput.files) {
                formData.append('files[]', file, file.webkitRelativePath);
            }

            statusDiv.textContent = 'Uploading...';

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`Upload failed! status: ${response.status}`);
                }
                const result = await response.json();
                statusDiv.textContent = `Upload successful: ${result.uploaded_files.join(', ')}`;
                fileInput.value = ''; // Clear the input
                browse(currentPath); // Refresh browser
            } catch (error) {
                statusDiv.textContent = `Upload error: ${error.message}`;
            }
        });

        // --- WebSocket Setup ---
        const socket = io();

        socket.on('connect', () => {
            console.log('Connected to WebSocket server.');
            document.getElementById('status-message').textContent = 'Connected';
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from WebSocket server.');
            document.getElementById('status-message').textContent = 'Disconnected';
        });

        socket.on('new_episode', (status) => {
            console.log('New episode event received:', status);
            const videoPlayer = document.getElementById('video-player');
            const expectedSrc = `${window.location.protocol}//${window.location.host}/media/${status.episode_path}`;

            if (videoPlayer.src !== expectedSrc && status.episode_path) {
                console.log("Browser out of sync. Updating video to:", status.episode_path);
                videoPlayer.src = `/media/${status.episode_path}`;
                videoPlayer.currentTime = status.current_time;
                if (status.is_playing) {
                    videoPlayer.play();
                } else {
                    videoPlayer.pause();
                }
            }
        });

        // --- Event Listeners ---
        const videoPlayer = document.getElementById('video-player');
        videoPlayer.addEventListener('ended', () => {
            console.log('Browser video ended. Requesting next episode.');
            sendCommand('/next');
        });

        // --- Initial Load ---
        browse('');
        // Request initial status
        fetch('/status').then(res => res.json()).then(status => {
            //
            // We are using the 'new_episode' handler to sync the browser with the device
            //
            socket.emit('new_episode', status);
        });
    </script>
</body>
</html>